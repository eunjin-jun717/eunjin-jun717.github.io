{"meta":{"title":"Eunjin's Blog","subtitle":"","description":"","author":"Eunjin Jun","url":"https://eunjin-jun717.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"hexo_python","date":"2021-04-06T06:51:18.658Z","updated":"2021-04-06T06:53:23.153Z","comments":true,"path":"2021/04/06/hexo_python/","link":"","permalink":"https://eunjin-jun717.github.io/2021/04/06/hexo_python/","excerpt":"","text":"파이썬 시각화 블로그 연습1234567891011121314import matplotlib.pyplot as pltdates = [ &#x27;2021-01-01&#x27;, &#x27;2021-01-02&#x27;, &#x27;2021-01-03&#x27;, &#x27;2021-01-04&#x27;, &#x27;2021-01-05&#x27;, &#x27;2021-01-06&#x27;, &#x27;2021-01-07&#x27;, &#x27;2021-01-08&#x27;, &#x27;2021-01-09&#x27;, &#x27;2021-01-10&#x27;]min_temperature = [20.7, 17.9, 18.8, 14.6, 15.8, 15.8, 15.8, 17.4, 21.8, 20.0]max_temperature = [34.7, 28.9, 31.8, 25.6, 28.8, 21.8, 22.8, 28.4, 30.8, 32.0]fig,axes = plt.subplots(nrows=1, ncols=1, figsize=(10,6))axes.plot(dates, min_temperature, label = &#x27;Min Temperature&#x27;)axes.plot(dates, max_temperature, label = &#x27;Max Temperature&#x27;)axes.legend()plt.show()","categories":[],"tags":[]},{"title":"","slug":"speed_list_tuple","date":"2021-04-05T15:00:00.000Z","updated":"2021-04-06T06:39:59.409Z","comments":true,"path":"2021/04/06/speed_list_tuple/","link":"","permalink":"https://eunjin-jun717.github.io/2021/04/06/speed_list_tuple/","excerpt":"","text":"List vs Tuple in python차이점 list는 mutable 즉, 생성된 후에 변경 가능하다.tuple은 immutable 즉, 생성된 후에 변경이 불가능하다. list는 dictionary의 key값으로 쓸 수 없지만 tuple은 가능하다.\\ why? key값은 불변한 값만 올 수 있기 때문!만약, tuple에 list가 들어있다면?=&gt; key 값으로 사용 불가능함! 참고) 문자열 또한 불변한 값이므로 dictionary의 key값으로 사용 가능하다. list 대신 tuple을 사용하는 이유는?메모리 크기 비교12345list_1 = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]tuple_1 = &#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;import sysprint(sys.getsizeof(list_1))print(sys.getsizeof(tuple_1)) 104 88 tuple이 메모리를 차이하는 것이 더 작은 것을 볼 수 있다. 생성 속도12%timeit list_2=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]%timeit tuple_2=&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27; 10000000 loops, best of 5: 57.5 ns per loop 100000000 loops, best of 5: 16.4 ns per loop tuple의 생성속도가 더 빠른 것을 확인할 수 있다. 인덱싱 속도12345list_3=[&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]%timeit list_3[0]tuple_3=&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;%timeit tuple_3[0] 10000000 loops, best of 5: 43 ns per loop 10000000 loops, best of 5: 42.8 ns per loop tuple이 list보다 indexing 으로 데이터에 접근하는 속도가 더 빠르다. 결과 메모리 크기비교, 생성속도, 인덱싱 속도에서 모두 tuple의 결과가 더 빠른것을 확인 할 수 있었다. 출처 https://codacoding.tistory.com/36 https://itholic.github.io/python-list-tuple/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://eunjin-jun717.github.io/tags/python/"}]},{"title":"기초 통계-상관분석","slug":"statistic","date":"2021-04-05T06:08:52.000Z","updated":"2021-04-06T04:46:52.546Z","comments":true,"path":"2021/04/05/statistic/","link":"","permalink":"https://eunjin-jun717.github.io/2021/04/05/statistic/","excerpt":"","text":"상관분석과 로지스틱회귀분석상관분석개념(정의) 연속 변수로 측정된 두 변수간의 선형 관계를 분석하는 기법 X가 증가함에 따라 B도 증가되는지 혹은 감소하는지를 분석기본 가정사항 두 변수 중 적어도 하나의 변수는 정규분포일 것 정규성 검사는 “shapiro.test()” 사용 만약, 두 변수 모두 정규성을 만족하지 못한다면? Spearman, Kendall 상관계수 사용! 정규성 검정에서 정규분포를 따르지 않거나 표본의 개수가 10개 미만일 때 사용 연속형 두 변수 간에는 선형적인 관계가 있어야함 분석을 실시하기 전, 반드시 두 변수의 산점도를 통해 확인해야함 공분산(Corvariance) 2개의 확률 변수의 상관정도를 나타내는 값 만약 하나의 값이 상승하는 경향을 보이면서 다른 값도 상승하면, 이때 공분산의 값은 양수! 하나의 값이 상승하는데 반대로 다른 값은 하강하면, 이때 공분산 값은 음수! 공분산 값만으로는 상승 or 하강의 경향을 알 수는 있으나 어느정도의 상관관계인지는 파악할 수 없음 따라서 공분산을 표준화 시킨 “상관계수”를 통해 파악하자! 상관관계 &amp; 상관계수(Correlation Coefficient) 상관관계 두 변수의 선형적인 관계 정도를 나타냄 일반적으로, 피어슨 상관계수를 의미 상관계수 피어슨 상관계수(Pearson) 상관계수(r)의 값: -1.0 &lt;= r &lt;= -0.7 (강한 음적 선형관계)-0.7&lt;= r &lt;= -0.3 (뚜렷한 음적 선형관계)-0.3&lt;= r &lt;= -0.1 (약한 음적 선형관계)-0.1&lt;= r &lt;= +0.1 (거의 무시될 수 있는 선형관계)+0.1&lt;= r &lt;= +0.3 (약한 양적 선형관계)+0.3&lt;= r &lt;= +0.73 (뚜렷한 양적 선형관계)+0.7&lt;= r &lt;= +1.0 (강한 양적 선형관계) 로지스틱 회귀분석로지스틱 회귀분석이 필요한 이유는?GLM(Generalized Linear Model) 비선형을 선형적으로 일반화 시킨 모형 이유는? 선형모델에서만 사용할 수 있는 모형의 해석, 확장, 수정 등을 이용하기 위해! 선형화 시키는 대상은? 관심 범주에 속할 확률 알코올 섭취량과 비만일 확률은 높아지지만 완전한 선형이라기 보다는 약간의 커브가 존재한다. 여기에 일반 선형회귀 라인을 넣으면 위와 같이 선형회귀선이 얼추 맞는다고 생각이 들 수 있다. 그렇지만 이 경우에는 음의 값이나 1을 초과하는 예측값을 제시할 수도 있는 가능성이 있다. 이러한 구조적 문제로 추가분석이 불가능하게 된다 그렇다면 비선형적인 모형을 넣어보면 어떨까? 훨씬 데이터에 잘 적용되는 것을 알 수 있다. 그렇지만 비선형모델은 여러 가지 추가 분석 제약이 있다! 따라서 이런 제약을 극복하기 위해 이를 선형화하는 것이 바로!! 로지스틱 회귀분석!! 이러한 특징을 만족하는 함수가 “시그모이드 함수”이다. 시그모이드 함수(로지스틱 반응함수)를 Odds에 넣는다. 확률p의 범위(0,1) -&gt; Odds(p)의 범위는(0,∞) 이다. Odds가 클수록 데이터가 해당 집단에 속할 확률이 큼 Odds에 log를 취하는데 이유는 선형으로 만들기 위해! 입력값(독립변수)의 범위가 –무한대에서 +무한대일 때, 출력값(종속변수)의 범위를 0에서 1로 변환시켜줌 X1, x2,…,xq가 어느 값을 가지더라도 항상 0과 1의 값을 가지게 된다. 1) 정의: 분류모델(기법) 일반적인 회귀분석과 동일하게 종속변수와 독립변수간의 관계를 함수로 나타내어 예측모델로 사용 특정기준(정답)에 의해 분석 대상을 특정개수의 집단으로 분류하는 예측모형 학습된 모델을 통해, 입력된 값을 미리 정해진 결과를 분류해주는 모델 이항형 로지스틱 회귀(Binary Logistic Regression): 2개의 범주Ex) 주택소유(있다/없다) 다항형 로지스틱 회귀(Multinomial Logistic Regression): 3개 이상의 범주Ex) 소유주택현황(아파트/단독주택/연립) 2) Odds(승산비) Odds란? 예측변수 1단위 변경 이후의 승산/ 원래 승산= 데이터가 어떤 집단에 속할 확률/ 속하지 않을 확률\\ 예를 들면, 나이의 Odds비가 0.969라면 나이가 한 단위 증가할수록 사망률이 0.969배 증가한다는 의미이다. 다시 말해, 생존율이 0.041배 감소한다. 3) 최대우도법 검정(Likelihood Ratio Test) 일반적인 회귀분석과 다르게 최대우도법 검정으로 추정을 한다!! 선형 회귀분석: 최소제곱법 로지스틱 회귀분석: 최대우도법 원하는 값이 나올 확률을 최대로 만드는 모수를 선택하는 방법 즉, 주어진 현상이 있을 때, 이 현상이 추출될 가능성을 가장 높게한다. 4) 이탈도(Deviance) 모형의 적합도의 측도 두 모형의 로그가능도 함수 값의 차이가 유의한지 보는 것 이때 포화모형이란 추정해야할 모수의 수가 데이터의 수와 동일한 상태 이탈도가 크면 그 모형은 적합하지 않다는 뜻 만약, p-value(&gt;0.05)이 클 때 모형 M이 의미있다는 뜻 5) AIC 이탈도와 다르게 로그가능도 함수 값과 모형에 사용된 모수의 수를 동시에 고려 로그가능도함수 값이 높으면 가산점을 준다!사용된 모수의 수가 많으면 패널티를 준다!따라서 AIC가 작을수록 바람직한 모형 Ex) 2개의 모형 모수를 이용한 모형의 로그가능도함수 값(LL)이 -16,4개의 모수만을 이용한 모형의 로그가능도함수 값(LL)이 -15 일 때,각 모형의 AIC =&gt; 36, 38 이다.비록 두번째 모형의 로그가능도함수 값이 -15로 더 컸지만,모형에 사용된 모수의 개수가 첫번째 모형보다 2개가 더 사용되었기 때문에 바람직하지 않다고 볼 수 있다. 6) 추가 Residual deviance(잔차이탈도) : 작을수록 좋고, 카이제곱분포를 따르기 때문에 카이제곱 적합도 검정을 통해 모형이 적합한지 확인가능 null deviance(0이탈도) : 아무런 변수 없이 상수항만 있을 때의 이탈도, 데이터가 전혀없는 최악의 상황 staturated model(포화모형) : 추정해야할 모수의 수가 데이터의 수와 동일한 상태 즉, 데이터가 10000개이면 추정할 모수의 수도 10000개 Null model(영 모델): 절편항만 가지는 모형으로 추정할 모수가 1개임 Proposed Model(제안모형): p개의 모수+ 절편항을 포함하는 모형으로, 추정할 모수가 p+1 개임. 참조 상관분석 상관분석 R 로지스틱회귀 이탈도 로그가능도, 이탈도","categories":[],"tags":[{"name":"statistic","slug":"statistic","permalink":"https://eunjin-jun717.github.io/tags/statistic/"}]},{"title":"Encoding error in R","slug":"error2","date":"2021-03-30T12:06:12.000Z","updated":"2021-03-30T23:58:47.922Z","comments":true,"path":"2021/03/30/error2/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/30/error2/","excerpt":"","text":"오류 상황 12Not all characters in C:&#x2F;Users&#x2F;study&#x2F;Desktop&#x2F;analysis&#x2F;logistic_hd.R could be decoded using CP949. To try a different encoding, choose &quot;File | Reopen with Encoding...&quot; from the main menu. R 파일을 여는데 위와 같은 오류문구가 발생하면서 글자가 거의 모두 깨져있었다. 해결방안 File -&gt; Reopen with encoding -&gt; UTF-8로 설정 설정을 완료하면 아래와 같이 해결된 것을 볼 수 있다. 오류가 난 이유 Mac OS나 Linux에서의 UTF-8로 인코딩되어 있는 상태에서 자료가 Windows로 넘어올 때 글자가 깨지는 현상이 발생할 수도 있다. 참조 https://nittaku.tistory.com/341","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://eunjin-jun717.github.io/tags/hexo/"}]},{"title":"troubleshooting in Hexo","slug":"error","date":"2021-03-29T12:23:23.000Z","updated":"2021-03-30T23:58:47.922Z","comments":true,"path":"2021/03/29/error/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/29/error/","excerpt":"","text":"오류 상황: npm을 통해서 설치를 완료하였는데도 아래와 같은 오류가 발생하였다. 1bash: hexo: command not found 해결 방안 우선 node와 npm이 제대로 설치되었는지 확인할 것 12$ node -v$ npm -v 정상적으로 설치되어 있다면, 다음 step을 따를 것step 1) 자신의 blog 폴더 (ex. myblog) -&gt; node_modules -&gt; .bin경로를 복사함 step 2) 시스템 속성 -&gt; 고급 탭 -&gt; 환경 변수 step 3) 시스템 변수에서 Path 클릭 -&gt; 편집 클릭 -&gt; 새로만들기 -&gt; 경로 붙여넣기 -&gt; 확인 step 4) 다시 열어서 hexo server로 테스트해보기 123$ hexo serverINFO Hexo is running at http:&#x2F;&#x2F;localhost:4000 . Press Ctrl+C to stop. bash: hexo: command not found가 나오지 않는다면 해결!! 참조 https://www.programmersought.com/article/45443350618/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://eunjin-jun717.github.io/tags/hexo/"}]},{"title":"apply함수와 for문의 속도 비교","slug":"for_apply","date":"2021-03-26T05:22:42.686Z","updated":"2021-03-29T00:00:31.862Z","comments":true,"path":"2021/03/26/for_apply/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/26/for_apply/","excerpt":"","text":"개념 정리apply 함수 apply(X, MARGIN, FUN, …) X: 배열, 매트릭스 Margin: 행(1), 열(2) Fun: 함수 12my.matrx &lt;- matrix(c(1:10, 11:20, 21:30), nrow = 10, ncol=3) # 행이 10개, 열이 3개인 매트릭스 생성my.matrx 1234567891011## [,1] [,2] [,3]## [1,] 1 11 21## [2,] 2 12 22## [3,] 3 13 23## [4,] 4 14 24## [5,] 5 15 25## [6,] 6 16 26## [7,] 7 17 27## [8,] 8 18 28## [9,] 9 19 29## [10,] 10 20 30 1apply(my.matrx, 1, sum) # 매트릭스를 행단위 합 계산 1## [1] 33 36 39 42 45 48 51 54 57 60 1apply(my.matrx, 2, sum) # 열단위 합 계산 1## [1] 55 155 255 1apply(my.matrx, 2, function(x) length(x)) # 직접 함수를 정의해서 사용 가능 1## [1] 10 10 10 lapply 함수 lapply(X,FUN, …) X: 벡터, 리스트 반환값: 리스트12vec &lt;- c(1:10)vec 1## [1] 1 2 3 4 5 6 7 8 9 10 1lapply(vec, sum) #list 형태로 나옴 1234567891011121314151617181920212223242526272829## [[1]]## [1] 1## ## [[2]]## [1] 2## ## [[3]]## [1] 3## ## [[4]]## [1] 4## ## [[5]]## [1] 5## ## [[6]]## [1] 6## ## [[7]]## [1] 7## ## [[8]]## [1] 8## ## [[9]]## [1] 9## ## [[10]]## [1] 10 12345A &lt;- c(1:9)B &lt;- c(1:12)C &lt;- c(1:15)my.lst &lt;- list(A,B,C)my.lst 12345678## [[1]]## [1] 1 2 3 4 5 6 7 8 9## ## [[2]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12## ## [[3]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1lapply(my.lst, sum) # 각 list 안의 값들의 합 12345678## [[1]]## [1] 45## ## [[2]]## [1] 78## ## [[3]]## [1] 120 sapply 함수 sapply(X,FUN,…,simplify=TRUE, USE.NAMES=TRUE) lapply와 같은 동작을 하지만, 가능하면 출력을 단순화 시키는 함수 simplify=TRUE : 출력을 단순화시킴, simplify=FALSE : 단순화 시키지 않음 USE.NAMES=TRUE : 이름 속성도 반환, USE.NAMES=FALSE : 이름 속성 없이 반환 1vec 1## [1] 1 2 3 4 5 6 7 8 9 10 1sapply(vec, sum, simplify=FALSE) # 출력을 단순화 하지 않으므로 리스트 형태로 출력 1234567891011121314151617181920212223242526272829## [[1]]## [1] 1## ## [[2]]## [1] 2## ## [[3]]## [1] 3## ## [[4]]## [1] 4## ## [[5]]## [1] 5## ## [[6]]## [1] 6## ## [[7]]## [1] 7## ## [[8]]## [1] 8## ## [[9]]## [1] 9## ## [[10]]## [1] 10 1sapply(vec, sum, simplify=TRUE) # 출력을 단순화시킴 1## [1] 1 2 3 4 5 6 7 8 9 10 1my.lst 12345678## [[1]]## [1] 1 2 3 4 5 6 7 8 9## ## [[2]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12## ## [[3]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1sapply(my.lst, sum) # 출력을 단순화시킴 # simplify=TRUE 생략된 모습 1## [1] 45 78 120 1lapply(my.lst, sum) # 리스트를 반환 12345678## [[1]]## [1] 45## ## [[2]]## [1] 78## ## [[3]]## [1] 120 vapply 함수 vapply(X,FUN,FUN.VALUE,…,USE.NAMES=TRUE) sapply함수와 비슷함. 차이점: value로 예상되는 데이터 유형을 지정해야함 FUN.VALUE: 자료형 지정 1vec 1## [1] 1 2 3 4 5 6 7 8 9 10 1vapply(vec, sum, numeric(1)) # 1개의 숫자데이터로 나오게함 1## [1] 1 2 3 4 5 6 7 8 9 10 1my.lst 12345678## [[1]]## [1] 1 2 3 4 5 6 7 8 9## ## [[2]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12## ## [[3]]## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 1vapply(my.lst, sum, numeric(1)) # 1개의 숫자데이터로 나오게함 1## [1] 45 78 120 12#vapply(my.lst, function(x) x, numeric(1)) # error 뜸#1개의 데이터만 들어갈 수 있는데 함수의 결과는 9개가 나오므로 error뜸 tapply 함수 tapply(X, INDEX, FUN=NULL, …, DEFAULT=NA,SIMPLIFY=TRUE) 그룹별로 처리함 factor형으로 인자를 줌 12tdata &lt;- as.data.frame(cbind(c(1,1,1,1,1,2,2,2,2,2), my.matrx)) # 열단위로 결합시킴tdata 1234567891011## V1 V2 V3 V4## 1 1 1 11 21## 2 1 2 12 22## 3 1 3 13 23## 4 1 4 14 24## 5 1 5 15 25## 6 2 6 16 26## 7 2 7 17 27## 8 2 8 18 28## 9 2 9 19 29## 10 2 10 20 30 1colnames(tdata) # tdata의 열 이름 1## [1] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;V4&quot; 1tapply(tdata$V2, tdata$V1, sum) # V1: index이며, V2가 함수의 인자로 전달됨 12## 1 2 ## 15 40 1# index가 1인 그룹으로 sum되고, index가 2인 그룹을 sum함 mapply 함수 mapply(FUN,…,MOREARGS=NULL, SIMPLIFY=TRUE, USE.NAMES=TRUE) sapply()와 유사하지만 mapply()는 다수의 인자를 함수에 넘길 수 있음 1mapply(rep, 1:10, 10:1) # 반복함수, 반복할 숫자, 반복되는 갯수 1234567891011121314151617181920212223242526272829## [[1]]## [1] 1 1 1 1 1 1 1 1 1 1## ## [[2]]## [1] 2 2 2 2 2 2 2 2 2## ## [[3]]## [1] 3 3 3 3 3 3 3 3## ## [[4]]## [1] 4 4 4 4 4 4 4## ## [[5]]## [1] 5 5 5 5 5 5## ## [[6]]## [1] 6 6 6 6 6## ## [[7]]## [1] 7 7 7 7## ## [[8]]## [1] 8 8 8## ## [[9]]## [1] 9 9## ## [[10]]## [1] 10 1tdata 1234567891011## V1 V2 V3 V4## 1 1 1 11 21## 2 1 2 12 22## 3 1 3 13 23## 4 1 4 14 24## 5 1 5 15 25## 6 2 6 16 26## 7 2 7 17 27## 8 2 8 18 28## 9 2 9 19 29## 10 2 10 20 30 12tdata$V5 &lt;- mapply(function(x,y) x*y, tdata$V1, tdata$V2) # V1과 V2의 값들에 대한 곱tdata 1234567891011## V1 V2 V3 V4 V5## 1 1 1 11 21 1## 2 1 2 12 22 2## 3 1 3 13 23 3## 4 1 4 14 24 4## 5 1 5 15 25 5## 6 2 6 16 26 12## 7 2 7 17 27 14## 8 2 8 18 28 16## 9 2 9 19 29 18## 10 2 10 20 30 20 For문, apply함수 속도 비교(1)For문 사용 시 속도123456789101112# 랜덤한 10000개의 숫자를 x1, x2에 저장N &lt;- 10000x1 &lt;- runif(N) # runif() : 랜덤숫자 발생함수x2 &lt;- runif(N)# x1과 x2를 열단위로 묶어서 d에 data frame 형태로 저장d &lt;- as.data.frame(cbind(x1, x2))# for loop으로 시간 체크system.time(for(i in c(1:length(d[,1])))&#123; # 1부터 &#x27;d의 1열 길이&#x27;만큼 for 문이 반복함 d$mean2[i] &lt;- mean(c(d[i,1], d[i,2])) # x1, x2 각각 더해 평균을 구한것을 d의 데이터 프레임에 넣음&#125;) 12## user system elapsed ## 0.80 0.05 0.84 For문은 1부터 10000까지 한 명이 순차적으로 일을 처리한다. apply 함수사용 시 속도12# apply 함수를 사용하여 같은 데이터를 처리해보자.system.time(d$mean1 &lt;- apply(d, 1, mean)) # d의 행에 대한 평균 12## user system elapsed ## 0.06 0.00 0.06 For문, apply함수 속도 비교(2)1install.packages(&#x27;nycflights13&#x27;, repos=&quot;http://cran.us.r-project.org&quot;) 1234## package &#39;nycflights13&#39; successfully unpacked and MD5 sums checked## ## The downloaded binary packages are in## C:\\Users\\study\\AppData\\Local\\Temp\\Rtmp08X2ug\\downloaded_packages 1install.packages(&#x27;dplyr&#x27;, repos=&quot;http://cran.us.r-project.org&quot;) 1234## package &#39;dplyr&#39; successfully unpacked and MD5 sums checked## ## The downloaded binary packages are in## C:\\Users\\study\\AppData\\Local\\Temp\\Rtmp08X2ug\\downloaded_packages 12library(dplyr)library(nycflights13) apply 함수사용 시 속도1head(flights) 123456789101112## # A tibble: 6 x 19## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;## 1 2013 1 1 517 515 2 830 819## 2 2013 1 1 533 529 4 850 830## 3 2013 1 1 542 540 2 923 850## 4 2013 1 1 544 545 -1 1004 1022## 5 2013 1 1 554 600 -6 812 837## 6 2013 1 1 554 558 -4 740 728## # ... with 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,## # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,## # hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 1234567891011flights_selected &lt;- select(flights, flight, distance) # flight number와 distance를 뽑음data_flight &lt;- tapply(flights_selected$distance, flights_selected$flight, sum) # 데이터 양이 많아 우선적으로 각각의 flight마다 간 거리를 합함.df &lt;- data.frame(flight_num= c(1:length(data_flight)), flight_distance= data_flight)# data frame 형태로 만듦 (인덱스 길이= flight 갯수)# flight_num와 distance의 평균을 구함, 의미는 없으며 속도차이를 보기 위함!## apply문 사용 시 속도 # 행단위로 평균을 구함system.time(df$mean3 &lt;- apply(df, 1, mean)) 12## user system elapsed ## 0.03 0.00 0.03 1234## For문 사용 시 속도system.time(for(i in c(1:length(data_flight)))&#123; df$mean2[i] &lt;- mean(c(df[i,1], df[i,2]))&#125;) 12## user system elapsed ## 0.28 0.02 0.29 apply함수 사용 시 장점 For문과 비교해봤을 때, apply함수 사용 시 속도가 빠음 대용량 데이터에 대해 짧은 코드로 반복 연산 처리 가능 참조 https://ademos.people.uic.edu/Chapter4.html#:~:text=Apply%20functions%20are%20a%20family,and%20often%20require%20less%20code. http://rstudio-pubs-static.s3.amazonaws.com/5526_83e42f97a07141e88b75f642dbae8b1b.html","categories":[],"tags":[]},{"title":"주택 가격: 시각화 예제","slug":"house_miniproj_eunjin","date":"2021-03-26T00:01:46.104Z","updated":"2021-03-26T08:00:44.226Z","comments":true,"path":"2021/03/26/house_miniproj_eunjin/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/26/house_miniproj_eunjin/","excerpt":"","text":"참조kaggle: house prices_ project r chunk에서 message=FALSE를 하게 되면 패키지를 불러올때의 관련 메세지가 안보임 12345678910111213library(knitr) # 마크다운 관련 패키지library(ggplot2) # 시각화 패키지library(plyr) # 데이터 분석, 가공 패키지library(dplyr) # 데이터 가공 패키지library(corrplot) # 상관행렬과 신뢰구간의 그래프library(caret) # 전처리, 모형 시각화library(gridExtra) # 시각화 이미지 분할library(scales) # ggplot2에 의해 사용된 scaling 인프라 제공library(Rmisc) # 데이터 분석, 유틸리티 동작library(ggrepel) # 겹치는 텍스트 레이블 제거library(randomForest) # 분류와 회귀를 위해 Breiman의 random forest algorithm 구현library(psych) # 기술통계량 구해주는 패키지#library(xgboost) # 머신러닝 패키지 R로 train.csv파일과 test.csv파일을 부름 12train &lt;-read.csv(&quot;train.csv&quot;, stringsAsFactors = F)test &lt;- read.csv(&quot;test.csv&quot;, stringsAsFactors = F) 1dim(train) # train의 데이터프레임 길이 1## [1] 1460 81 1str(train[,c(1:10, 81)]) # 처음 10개의 변수와 response variable 123456789101112## &#39;data.frame&#39;: 1460 obs. of 11 variables:## $ Id : int 1 2 3 4 5 6 7 8 9 10 ...## $ MSSubClass : int 60 20 60 70 60 50 20 60 50 190 ...## $ MSZoning : chr &quot;RL&quot; &quot;RL&quot; &quot;RL&quot; &quot;RL&quot; ...## $ LotFrontage: int 65 80 68 60 84 85 75 NA 51 50 ...## $ LotArea : int 8450 9600 11250 9550 14260 14115 10084 10382 6120 7420 ...## $ Street : chr &quot;Pave&quot; &quot;Pave&quot; &quot;Pave&quot; &quot;Pave&quot; ...## $ Alley : chr NA NA NA NA ...## $ LotShape : chr &quot;Reg&quot; &quot;Reg&quot; &quot;IR1&quot; &quot;IR1&quot; ...## $ LandContour: chr &quot;Lvl&quot; &quot;Lvl&quot; &quot;Lvl&quot; &quot;Lvl&quot; ...## $ Utilities : chr &quot;AllPub&quot; &quot;AllPub&quot; &quot;AllPub&quot; &quot;AllPub&quot; ...## $ SalePrice : int 208500 181500 223500 140000 250000 143000 307000 200000 129900 118000 ... 123test_labels &lt;- test$Id # 테스트 Id는 test_labels에 저장test$Id &lt;- NULLtrain$Id &lt;- NULL 123test$SalePrice &lt;- NA # Not Available 결측치, NULL은 출력되지 않지만 NA는 출력됨all &lt;- rbind(train, test) # train과 test 결합dim(all) # 결합된 것을 all이라하며 데이터 프레임 길이 구함 1## [1] 2919 80 1#Id가 없으므로 (데이터프레임 = 79개의 예측변수들 + SalePrice 인 response 변수) 123456ggplot(data = all[!is.na(all$SalePrice),], #SalePrice에 결측값인 NA가 포함되어있는지 확인함 # 이때 결측값이 아닌 SalePrice 만 선택 aes(x= SalePrice))+ # x축 : SalePrice geom_histogram(fill=&quot;blue&quot;, binwidth = 10000)+ # 히스토그램으로 표현, bar은 blue, bar의 두께는 10000으로 설정 scale_x_continuous(breaks=seq(0, 800000, by=100000), # x축의 범위는 0~800000, 100000단위로 끊어줌 labels= comma) # 숫자 3자리마다 &#x27;,&#x27; 넣음 히스토그램을 보면 좌측으로 치우쳐져 있다.이 말은 SalePrice가 낮은 집이 잘 팔린다는 뜻이고, SalePrice가 높은 집은 사는 사람이 거의 없다는 것을 의미한다. 1summary(all$SalePrice) 12## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 34900 129975 163000 180921 214000 755000 1459 SalePrice의 최저가격: 34,900, 최고가격: 755,000,1사 분위수(1st Qu): 129,975 =&gt; 오름차순으로 정렬했을 때, 하위 25%의 SalePrice중앙값(Median): 163,000 =&gt; 오름차순으로 정렬했을 때, 중앙에 있는 값인 SalePrice평균값(Mean): 180,921 =&gt; SalePrice의 평균1사 분위수(3rd Qu): 214,000 =&gt; 오름차순으로 정렬했을 때, 상위 25%의 SalePriceNA’s : 결측값 123numericVars &lt;- which(sapply(all, is.numeric)) # numeric 변수들의 위치를 찾는데 그 결과를 벡터 또는 행렬로 반환numericVarNames &lt;- names(numericVars) # 저장된 numeric 변수들인 numericVars로 변수명 변경된 것을 Name벡터인 numericVarNames로 저장cat(&#x27;There are&#x27;, length(numericVars), &#x27;numeric variables&#x27;) #cat함수는 행을 바꾸지 않음 1## There are 37 numeric variables 123456789101112131415#numericVars의 갯수를 출력함all_numVar &lt;- all[, numericVars] # numericVars의 데이터들을 &#x27;all_numVar&#x27;에 저장 (numericVars는 그냥 벡터일뿐, 데이터프레임이 아님)cor_numVar &lt;- cor(all_numVar, use=&quot;pairwise.complete.obs&quot;) # all_numVar들의 상관관계를 저장# use=&quot;pairwise.complete.obs&quot; =&gt; 결측치가 포함된 데이터에서 상관관계를 구하기 위해 사용cor_sorted &lt;- as.matrix(sort(cor_numVar[, &#x27;SalePrice&#x27;], decreasing = TRUE)) # SalePrice와의 상관관계만을 내림차순으로 정렬한 뒤 행렬로 변환한 것을 cor_sorted 행렬에 저장CorHigh &lt;- names(which(apply(cor_sorted, 1, function(x) abs(x)&gt;0.5))) # 1:행, 2:열, function(x) &#123; abs (x)&#125;# 행단위로 SalePrice의 상관관계를 절댓값 형태로 취한 뒤 0.5 이상의 값만 추출함# 추출된 것들의 변수명을 변경하고 CorHigh에 저장 =&gt; 0.5이상의 상관관계는 &quot;관련이 높다&quot;라는 의미cor_numVar &lt;- cor_numVar[CorHigh, CorHigh] # 0.5이상의 상관관계를 가진 값들로만 cor_numVar에 다시 저장# tl.col(text legend color은 black), tl.pos(text legend position은 left와 top)# corrplot.mixed 함수: 시각화 방법을 혼합할 때 사용corrplot.mixed(cor_numVar, tl.col= &quot;black&quot;, tl.pos=&quot;lt&quot;) #tl: text legend, cl: color legend 상관관계가 0.5이상인 데이터들을 봤을 때, SalePrice와 가장 높은 상관관계를 가지는 것은 “OverallQual”인 전반적인 품질이었다. =&gt; 0.791 독립변수들 간에 강한 상관관계가 나타나는 문제를 multicollinearity (다중공선성)라고 하는데 이것이 문제인 것으로 보인다. SalePrice와 가장 상관관계가 높은 OverallQual를 제외하고 다음으로 높은 GrLivArea 와 GarageCars 사이의 상관관계를 보았을 때 매우 높은 0.8897 이다. 즉, 독립변수들 간의 강한 상관관계를 나타낸다. 상관관계가 0.5 이상인 높은 상관관계를 가진 변수는 나머지 6개가 있다.TotalBsmtSF, 1stFlrSF, FullBath, TotRmsAbvGrd, YearBuilt, YearRemodAdd","categories":[],"tags":[],"author":"Eunjin"},{"title":"R코딩 기초함수","slug":"R-edu2","date":"2021-03-23T13:53:23.000Z","updated":"2021-03-26T08:00:44.237Z","comments":true,"path":"2021/03/23/R-edu2/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/23/R-edu2/","excerpt":"","text":"Visualization Practice using “counties”파일 불러오기 get working directory 라는 뜻으로 현재 위치를 알려준다.1getwd() set as working directory 라는 뜻으로 위치를 새로 설정할 수 있다.1setwd(&#x27;R_NCS_2020/1_day/&#x27;) dplyr 설치 방법 2가지 method1) tidyverse 설치 12install.packages(&quot;tidyverse&quot;)library(tidyverse) method2) dplyr만 설치 12install.packages(&quot;dplyr&quot;)library(dplyr) 데이터 가져오기 data 폴더에 있는 counties.xlsx 파일을 가져온다.만약 경로 error가 뜨면 getwd()를 하여 현재 파일 위치가 잘못되어있는지 확인해본다. 1counties &lt;- readxl::read_xlsx(&quot;data/counties.xslx&quot;, sheet = 1) 데이터 확인 glimpse 를 사용하여 counties에 무슨 변수들이 있는지 살펴볼 수 있다. 1glimpse(counties) Select 사용하여 원하는 변수들 추출 counties 변수들 중에서 state, region, men, women, population 변수들의 데이터만 고른다.select한 것을 counties_selected라는 변수 이름으로 저장한다. counties_selected 를 state 기준으로 내림차순 정렬한다. 12345counties_selected &lt;- counties %&gt;% select(state, region, men, women, population) counties_selected %&gt;% arrange(desc(state)) Filter 사용하여 불필요한 것 제거하고 보기 population이 10000명 이하인 것들만 보여준다.12counties_selected %&gt;% filter(population &lt; 10000) 조건이 두가지일 경우에는 아래와 같이 한다. state가 California이거나 population이 100000명 이상인 것을 추출한다. 12counties_selected %&gt;% filter(state == &quot;California&quot; | population &gt; 100000) Arange 함수 오름차순, 내림차순으로 정렬 가능하다.123counties_selected %&gt;% filter(state == &quot;California&quot; | population &gt; 100000) %&gt;% arrange(desc(public_work)) Mutate 함수 새로 변수를 추가한다는 것 보다는 의미있는 데이터 발견하고자 할 때 사용한다. public workers를 구해서 배열하는 코드이다. 123456counties_seletec &lt;- counties %&gt;% select(state, county, private_work, public_work, population)counties_seleteced %&gt;% mutate(public_workers = population * private_work /100) %&gt;% arrange(public_workers) Count 함수 각 행의 갯수를 셀 수 있고, 정렬까지 가능하다. sort=TRUE이면 자동으로 내림차순12counties_selected %&gt;% count(state, sort =TRUE) 가중치를 두어 주별로 걸어서 출퇴근하는 사람의 수를 카운트할 수 있다. 12counties_selected %&gt;% count(state, wt= walkers_pop) 참조 https://github.com/dschloe/R_edu","categories":[],"tags":[{"name":"r","slug":"r","permalink":"https://eunjin-jun717.github.io/tags/r/"}]},{"title":"R코딩 기초1","slug":"R-edu1","date":"2021-03-23T13:06:56.000Z","updated":"2021-03-26T08:00:44.235Z","comments":true,"path":"2021/03/23/R-edu1/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/23/R-edu1/","excerpt":"","text":"R 코딩 기초실행방법 Windows: Ctrl + Enter Mac: Command + Enter 변수 저장 시1a &lt;- 3 Alt + - key 누르면 된다. 변수 호출 시123print(x) #혹은x 변수 종류변수 type 숫자형 변수 1my_numeric &lt;- 17 문자형 변수 1my_character &lt;- &quot;eunjin&quot; 논리형 변수 12my_logical &lt;- FALSE my_logical &lt;- TRUE 벡터 생성12number_vector &lt;- c(1,2,3)number_vertor &lt;- c(1,&quot;2&quot;,3) 첫번째 라인은 숫자로만 이루어져있기 때문에 변수 type을 알아보면 “numeric” 으로 나온다. 두번째 라인은 숫자, 문자가 섞여져 있다.이때 컴퓨터는 문자형 -&gt; 숫자형 -&gt; 논리형 으로 저장된다.따라서 두번째 라인의 변수 type은 문자형이 나온다. =&gt; “character” 1class(number_vector) 변수 type을 알아볼때는 class()를 사용한다. 범주형 변수의 순서 Levels: 낮음 높음123height_vector &lt;- c(&quot;낮음&quot;, &quot;높음&quot;, &quot;낮음&quot;)factor_height_vector &lt;- factor(height_vector)factor_height_vector Levels 순서 바꾸기 =&gt; 높음 낮음12levels(factor_sex_vector) &lt;- c(&quot;남성&quot;, &quot;여성&quot;)factor_sex_vector Levels 이름 변경 =&gt; Levels: 매우높음 매우낮음1234factor_height_vector &lt;- factor(factor_height_vector, levels = c(&quot;매우높음&quot;, &quot;매우낮음&quot;))factor_height_vector 참조 https://github.com/dschloe/R_edu","categories":[],"tags":[{"name":"r","slug":"r","permalink":"https://eunjin-jun717.github.io/tags/r/"}]},{"title":"What is the main and branch in Github","slug":"meaning","date":"2021-03-23T12:40:58.000Z","updated":"2021-03-26T08:00:44.237Z","comments":true,"path":"2021/03/23/meaning/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/23/meaning/","excerpt":"","text":"Main 과 Branch 그림에서 보이는 main과 branch의 역할이 무엇인지 궁금하여 찾아보았다. Branch란? 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능 각자 독립적인 저장소안에서 소스코드를 원하는대로 작업할 수 있다. 분리된 작업들을 나중에 하나의 새로운 버전으로 만들어낼 수 있다. 장점: 여러 작업들을 동시에 진행할 수 있다. 문제가 발생했을 경우 원인이 되는 작업을 찾아내 대책을 세우기 쉽다.Main이란? default branch 참조https://backlog.com/git-tutorial/kr/stepup/stepup1_1.html","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://eunjin-jun717.github.io/tags/github/"}]},{"title":"visualization","slug":"visualization","date":"2021-03-22T13:09:02.000Z","updated":"2021-03-26T08:00:44.230Z","comments":true,"path":"2021/03/22/visualization/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/22/visualization/","excerpt":"","text":"간단하게 시각화 하는 과정 step1) 패키지 설치1install.packages(&quot;ggplot2&quot;) step2) 패키지 불러오기1library(ggplot2) step3) 데이터 불러오기1data(&quot;iris&quot;) step4) 데이터 확인하기1str(iris) step5) 가공되지 않은 Raw data 가공하기 step6) 시각화하기12345ggplot(data=iris, mapping = aes(x = Petal.Length, y = Petal.Width, colour = Species)) + geom_point(size=3) *tap 누르면 자동입력기능 있음.*help에서 ggplot sample 확인 가능. 참조 https://github.com/dschloe/R_edu","categories":[],"tags":[]},{"title":"How to create a blog with Hexo","slug":"firstday","date":"2021-03-22T12:38:36.000Z","updated":"2021-03-26T08:00:44.237Z","comments":true,"path":"2021/03/22/firstday/","link":"","permalink":"https://eunjin-jun717.github.io/2021/03/22/firstday/","excerpt":"","text":"github에 2개의 Repository 생성 포스트 버전관리: user_name 포스트 배포용 관리: user_name.github.io Blog 초기화$ hexo init myblog Hexo 모듈 설치$ npm install -g hexo-cli myblog로 들어간 뒤 아래와 같이 입력$ cd myblog$ npm install$ npm install hexo-server –save$ npm install hexo-deployer-git –save 참고로, 복사+붙여넣기 하면 오류를 줄일 수 있음 Local server로 테스트$ hexo server Pycharm pycharm을 열어서 myblog 폴더를 연다. config.yml 파일을 열어 title, author을 수정한다.title: Eunjin’s Blogauthor: Eunjin Jun URL도 아래와 같이 수정한다. url: https://user_name.github.io Deployment의 deploy를 아래와 같이 입력한다.deploy:type: gitrepo: https://github.com/user_name/user_name.github.io.gitbranch: main Hexo generate &amp; deploy 활성화시킨 뒤 배포한다.$ hexo generate$ hexo deploy 한꺼번에 명령을 할 수도 있다.$ hexo deploy –generate Themes 설치ex) icarus 설치 icarus 설치$ npm install hexo-theme-icarus config.yml의 Extensions의 theme을 icarus로 변경theme: icarus $ hexo server이때, Error에서 뜨는 설명대로 그대로 복사한 뒤 붙여넣기하여 설치하기$ npm install –save &#x62;&#x75;&#x6c;&#109;&#97;&#45;&#115;&#x74;&#121;&#108;&#117;&#115;&#x40;&#48;&#46;&#x38;&#46;&#48; hexo-renderer-inferno@^0.1.3 다시 local server 테스트$ hexo server$ hexo deploy –generate 참조 https://dschloe.github.io/settings/hexo_blog/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://eunjin-jun717.github.io/tags/hexo/"}]}],"categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://eunjin-jun717.github.io/tags/python/"},{"name":"statistic","slug":"statistic","permalink":"https://eunjin-jun717.github.io/tags/statistic/"},{"name":"hexo","slug":"hexo","permalink":"https://eunjin-jun717.github.io/tags/hexo/"},{"name":"r","slug":"r","permalink":"https://eunjin-jun717.github.io/tags/r/"},{"name":"github","slug":"github","permalink":"https://eunjin-jun717.github.io/tags/github/"}]}